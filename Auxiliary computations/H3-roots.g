#### Realisation of the root system H3 as a folding of D6

K := CF(5); # Ground field: Rationals adjoined fifth root of unity
gold := (1 + Sqrt(5))/2; # Golden ratio, contained in K

## The root system D6
D6Vec := FullRowSpace(K, 6); # Euclidean space containing D6
# Standard orthonormal basis
e1 := [1, 0, 0, 0, 0, 0];
e2 := [0, 1, 0, 0, 0, 0];
e3 := [0, 0, 1, 0, 0, 0];
e4 := [0, 0, 0, 1, 0, 0];
e5 := [0, 0, 0, 0, 1, 0];
e6 := [0, 0, 0, 0, 0, 1];
e := [e1, e2, e3, e4, e5, e6];
# Initialise the root system D6 and its positive system
D6 := [];
D6Pos := [];
for i in [1..6] do
	for j in [1..6] do
		if i <> j then
			Add(D6, e[i] - e[j]);
			if i < j then
				Add(D6Pos, e[i] - e[j]);
				Add(D6, e[i] + e[j]);
				Add(D6Pos, e[i] + e[j]);
				Add(D6, -e[i] - e[j]);
			fi;
		fi;
	od;
od;
D6Sim := [ e1-e2, e2-e3, e3-e4, e4-e5, e5-e6, e5+e6 ]; # Standard root basis of D6
# Diagram of D6 with respect to D6Sim:
#             6
#             |
# 1 - 2 - 3 - 4 - 5
# i.e.
# 1 - 2 - 3
#       /
# 6 - 4 - 5

## Reflection map
# alpha, beta: Elements of D6Vec
# Output: The image of beta under the reflection along alpha^\perp
refl := function(alpha, beta)
	local coeff;
	coeff := 2 * (alpha*beta)/(alpha*alpha);
	return beta - coeff*alpha;
end;

## The subspaces W1 and W2 of D6Vec, as defined in [BW, 4.5]
# List of basis vectors
W1BasList := [ D6Sim[4] - gold*D6Sim[2], D6Sim[3] - gold*D6Sim[5], D6Sim[6] - gold*D6Sim[1] ];
W2BasList := [ D6Sim[2] + gold*D6Sim[4], D6Sim[5] + gold*D6Sim[3], D6Sim[1] + gold*D6Sim[6] ];
# The subspaces
W1 := Subspace(D6Vec, W1BasList);
W2 := Subspace(D6Vec, W2BasList);
# The bases as basis objects in GAP
W1Bas := Basis(W1, W1BasList);
W2Bas := Basis(W2, W2BasList);
D6VecWBas := Basis(D6Vec, Concatenation(W1BasList, W2BasList)); # Basis of D6Vec

## Projection maps
# alpha: Element of D6Vec
# Output: The projection on alpha onto W1 or W2, respectively
projW1 := function(alpha)
	local coeff, vectors;
	coeff := Coefficients(D6VecWBas, alpha);
	vectors := Concatenation(W1BasList, [Zero(D6Vec), Zero(D6Vec), Zero(D6Vec)]);
	return coeff * vectors;
end;
projW2 := function(alpha)
	local coeff, vectors;
	coeff := Coefficients(D6VecWBas, alpha);
	vectors := Concatenation([Zero(D6Vec), Zero(D6Vec), Zero(D6Vec)], W2BasList);
	return coeff * vectors;
end;

## Definition of GH3 and H3
GH3 := List(D6, projW2);
GH3Pos := List(D6Pos, projW2);

# List of root lengths which occur in GH3. The test functions in H3-test.g verify that this is a list with two elements whose second element is gold^2 times the first element.
rootLengthsInGH3 := Set(List(GH3, alpha -> alpha*alpha));

# alpha: Root in GH_3
# Output: True if alpha is short (in GH3) and false otherwise
GH3RootIsShort := function(alpha)
	return (alpha * alpha = rootLengthsInGH3[1]);
end;

# H3 consists of all short roots in GH3
H3 := Filtered(GH3, GH3RootIsShort);
H3Pos := Filtered(GH3Pos, GH3RootIsShort);

# beta: Root in GH_3.
# Output: The unique root alpha in D_6 with projW2(alpha) = beta.
projW2Inv := function(beta)
	local alpha;
	for alpha in D6 do
		if projW2(alpha) = beta then
			return alpha;
		fi;
	od;
	return fail;
end;

# alpha: Root in GH_3.
# Output: alpha if alpha is short, otherwise (1/gold)*alpha. By the verification testGH3IsGoldenH3, scaleMap(alpha) is the unique shortest root in GH_3 in the same ray as alpha.
# In [BW], we scale to the unit sphere, but this makes no difference for our arguments.
scaleMap := function(alpha)
	if GH3RootIsShort(alpha) then
		return alpha;
	else
		return (1/gold)*alpha;
	fi;
end;

# alpha: Root in H_3.
# Output: A list [ beta, gamma ] of the unique roots in D6 such that projW2(beta) = alpha and projW2(gamma) = gold*alpha.
FoldingPreimage := function(alpha)
	return [ projW2Inv(alpha), projW2Inv(gold*alpha) ];
end;

# Root basis of H3
H3Sim := [ scaleMap(projW2(D6Sim[1])), scaleMap(projW2(D6Sim[2])), scaleMap(projW2(D6Sim[3])) ];
H3SimBas := Basis(W2, H3Sim);

# Coefficients of the roots in H3 with respect to H3Sim
H3Coeffs := List(H3, alpha -> Coefficients(H3SimBas, alpha));
H3PosCoeffs := List(H3Pos, alpha -> Coefficients(H3SimBas, alpha));

# ---- Auxiliary functions ----

# rootSystem: A root system (whose elements lie in some vector space).
# rootList: A subset of rootSystem.
# Output: The root subsystem generated by rootList.
generatedSubsystem := function(rootSystem, rootList)
	local vecspace, subspace;
	vecspace := VectorSpace(K, rootSystem);
	subspace := Subspace(vecspace, rootList);
	return Intersection(rootSystem, subspace);
end;

# alpha, beta: Roots in H3.
# Output: true if (alpha, beta) is an H2-pair, otherwise false.
IsH2Pair := function(alpha, beta)
	return ((alpha*beta) / (alpha*alpha) = -gold/2);
end;

# alpha, epsilon: An H2-pair in H3.
# Output: The corresponding H2-quintuple.
H2QuintupleFromPair := function(alpha, epsilon)
	if not IsH2Pair(alpha, epsilon) then
		return fail;
	else
		return [ alpha, gold*alpha+epsilon, gold*(alpha+epsilon), alpha+gold*epsilon, epsilon ];
	fi;
end;

# startRoot: A root in H3.
# Output: A list of all four H2-quintuples starting from startRoot.
H2QuintuplesStartingFromRoot := function(startRoot)
	local H2PairRoots;
	H2PairRoots := Filtered(H3, alpha -> IsH2Pair(startRoot, alpha));
	return List(H2PairRoots, alpha -> H2QuintupleFromPair(startRoot, alpha));
end;