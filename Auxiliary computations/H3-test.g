#### Test functions for H3 and GH3. Must be loaded after H3-roots.g and H3-group.

## ---- Tests for combinatorial properties of the root systems H_3 and GH_3 ----

# Returns true if the decomposition D6Vec = W1 + W2 is orthogonal, otherwise false. Claimed in [BW, 4.5].
testDecompIsOrtho := function()
	local i, j;
	for i in [1..3] do
		for j in [1..3] do
			if W1BasList[i] * W2BasList[j] <> Zero(K) then
				return false;
			fi;
		od;
	od;
	return true;
end;

# Returns true if the decomposition D6Vec = W1 + W2 is R-invariant, otherwise false. Here R denotes the set of simple reflections in Weyl(H3). Claimed in [BW, 4.5].
testDecompIsInvar := function()
	local R, r, v;
	R := [ x -> refl(D6Sim[1], refl(D6Sim[6], x)),
			x -> refl(D6Sim[3], refl(D6Sim[5], x)),
			x -> refl(D6Sim[2], refl(D6Sim[4], x)) ];
	for r in R do
		for v in W1BasList do
			if not r(v) in W1 then
				return false;
			fi;
		od;
		for v in W2BasList do
			if not r(v) in W2 then
				return false;
			fi;
		od;
	od;
	return true;
end;

# Returns true if GH3 is the disjoint union of H3 and gold*H3, otherwise false. Claimed in [BW, 4.5].
testGH3IsGoldenH3 := function()
	if Length(H3) <> 30 or Length(GH3) <> 60 then
		return false;
	elif rootLengthsInGH3 <> [rootLengthsInGH3[1], gold^2*rootLengthsInGH3[1]] then
		return false;
	else
		return (Set(GH3) = Set(Concatenation(H3, gold*H3)));
	fi;
end;

# Returns true if H_3 is invariant under all reflections sigma_alpha for alpha in H_3, i.e. if it is indeed a root system. Claimed in [BW, 4.5].
testH3IsRootSystem := function()
	local alpha, beta;
	for alpha in H3 do
		for beta in H3 do
			if not refl(alpha, beta) in H3 then
				return false;
			fi;
		od;
	od;
	return true;
end;

# Returns true if the assertion of [BW, 4.13] is true, i.e. \sigma_{D6Sim[i]} \sigma_{D6Sim[j]}, \sigma(projW2(D6Sim[i])) and \sigma(projW2(D6Sim[j])) act identically on GH3 for all (i,j) in { (1,6), (3,5), (2,4) }.
testReflActionLem := function()
	local pair, i, j, r, r1, r2, alpha;
	for pair in [ [1,6], [3,5], [2,4] ] do
		i := pair[1];
		j := pair[2];
		r := x -> refl(D6Sim[j], refl(D6Sim[i], x));
		r1 := x -> refl(projW2(D6Sim[i]), x);
		r2 := x -> refl(projW2(D6Sim[j]), x);
		for alpha in D6 do
			if r(projW2(alpha)) <> r1(projW2(alpha)) or r(projW2(alpha)) <> r2(projW2(alpha)) then
				return false;
			fi;
		od;
	od;
	return true;
end;

# r: Element of K = CF(5).
# Replaces gold, gold^2, 2*gold by "t", "t^2" and "2t", respectively.
makeGoldReadable := function(r)
	if r = gold then
		return "t";
	elif r = gold^2 then
		return "t^2";
	elif r = 2*gold then
		return "2t";
	else
		return r;
	fi;
end;

# Returns true if the assertion of [BW, 2.12] is true, i.e. each root in H3 is contained in precisely 2 subsystems of type A1 x A2, 2 subsystems of type A2 and 2 subsystems of type H2. (By the transitivity of the Weyl group on H3, it suffices to check this for one root.)
testH3SubsysProp := function()
	local baseroot, subsystems, alpha, numA1A1, numA2, numH2;
	baseroot := H3Sim[1]; # Root for which the property is checked
	# Compute all subsystems of H3 generated by baseroot and another root
	subsystems := [];
	for alpha in H3 do
		AddSet(subsystems, generatedSubsystem(H3, [ baseroot, alpha ]));
	od;
	# Subsystems of type A1 x A1, A2 or H2 are characterised by the fact that they have precisely 4, 6 or 10 elements, respectively.
	numA1A1 := Size(Filtered(subsystems, x -> (Size(x) = 4)));
	numA2 := Size(Filtered(subsystems, x -> (Size(x) = 6)));
	numH2 := Size(Filtered(subsystems, x -> (Size(x) = 10)));
	return (numA1A1 = 2 and numA2 = 2 and numH2 = 2);
end;

# Returns true if the assertion of [BW, 5.16] is true, otherwise false. (By the transitivity of the Weyl group, it suffices to check this for one choice of alpha.)
testTwoA2Prop := function()
	local alpha, H2Quints, H2Quint1, H2Quint2, H2Sub1, H2Sub2, bRhoFound, rho;
	alpha := H3Sim[2];
	H2Quints := H2QuintuplesStartingFromRoot(alpha);
	for H2Quint1 in H2Quints do
		for H2Quint2 in H2Quints do
			H2Sub1 := generatedSubsystem(H3, H2Quint1);
			H2Sub2 := generatedSubsystem(H3, H2Quint2);
			if not IsEqualSet(H2Sub1, H2Sub2) then
				# If the assertion of the lemma is incorrect for this choice of H2-quintuples, return false.
				bRhoFound := false; # Whether rho as in the lemma was found
				for rho in [ H2Quint2[3], H2Quint2[4] ] do
					if Size(generatedSubsystem(H3, [ rho, H2Quint1[2] ])) = 6 and Size(generatedSubsystem(H3, [ rho, H2Quint1[3] ])) = 6 then
						bRhoFound := true;
						break;
					fi;
				od;
				# No suitable rho was found -> return false
				if not bRhoFound then
					return false;
				fi;
			fi;
		od;
	od;
	# Return true if the assertion is satisfied for all choices of H2Quint1 and H2Quint2
	return true;
end;

## ---- Tests of the commutator relations in the folding ----

# Returns true if the commutator relations in [BW, 4.12, Figure 5] hold.
testComRels := function()
	local a, b, c, d, quint, comm, testComRel;
	a := Indeterminate(Integers, 1);
	b := Indeterminate(Integers, 2);
	c := Indeterminate(Integers, 3);
	d := Indeterminate(Integers, 4);
	quint := H2QuintupleFromPair(H3Sim[2], H3Sim[3]);
	# Returns the commutator of two generic elements of the corresponding root groups
	comm := function(root1, root2)
		return H3RootHom(root1, [ -a, -b]) * H3RootHom(root2, [ -c, -d ]) * H3RootHom(root1, [ a, b ]) * H3RootHom(root2, [ c, d ]);
	end;
	testComRel := function(root1, root2, test)
		if test <> comm(root1, root2) then
			return false;
		fi;
	end;
	## Commutator relation in the A_2-subsystem
	testComRel(H3Sim[1], H3Sim[2], H3RootHom(H3Sim[1]+H3Sim[2], [ a*c, b*d ]));
	## Commutator relations in the H_2-subsystem
	# Roots with one root between them
	testComRel(quint[1], quint[3], H3RootHom(quint[2], [ 0, a*c ]));
	testComRel(quint[2], quint[4], H3RootHom(quint[3], [ 0, -a*c ]));
	testComRel(quint[3], quint[5], H3RootHom(quint[4], [ 0, a*c ]));
	# Roots with two roots between them
	testComRel(quint[1], quint[4], H3RootHom(quint[2], [ 0, -b*c ]) * H3RootHom(quint[3], [ 0, a*d ]));
	testComRel(quint[2], quint[5], H3RootHom(quint[3], [ 0, b*c ]) * H3RootHom(quint[4], [ 0, -a*d ]));
	# Roots with three roots between them
	testComRel(quint[1], quint[5], H3RootHom(quint[2], [ b*c, a*b*d ]) * H3RootHom(quint[3], [ -b*d, a*b*c*d ]) * H3RootHom(quint[4], [ a*d, -b*c*d ]));
	# Everything was ok
	return true;
end;

## ---- Computation of the parity map ----

# Returns a list with one entry for each positive root alpha in H3. Each entry is a list [ coeff, b1, b2 ] where coeff is the coefficient list of alpha with respect to H3Sim, b1 is the unique root in D6 with projW2(b1) = alpha and b2 is the unique root in D6 with projW2(b2) = gold*alpha. I.e. the output is precisely [BW, Figure 2].
H3PosFoldingTable := function()
	local coeff, resultList, GH3ShortRoot, GH3LongRoot;
	resultList := [];
	for coeff in H3PosCoeffs do
		GH3ShortRoot := coeff * H3Sim; # alpha
		GH3LongRoot := gold * GH3ShortRoot; # gold*alpha
		coeff := List(coeff, makeGoldReadable);
		Add(resultList, [ coeff, projW2Inv(GH3ShortRoot), projW2Inv(GH3LongRoot) ]);
	od;
	return resultList;
end;

# Returns a list with one entry for each positive root alpha in H3. Each entry is a list [ coeff, e1, e2, e3 ] where coeff is the coefficient list of alpha with respect to H3Sim and ei is the parity of the Weyl element of H3Sim[i] on alpha. I.e. the output is precisely [BW, Figure 5] and the function verifies [BW, 6.16].
H3ParityTable := function()
	local resultList, i, j, coeff, entry;
	resultList := [];
	for i in [1..Length(H3Pos)] do
		coeff := List(H3PosCoeffs[i], makeGoldReadable);
		entry := [ coeff ];
		for j in [1..3] do
			Add(entry, H3Parity(H3Pos[i], H3Sim[j]));
		od;
		Add(resultList, entry);
	od;
	return resultList;
end;

# Returns true if H3Parity(alpha, delta) = H3Parity(-alpha, delta) for all alpha in H3 and delta in H3Sim. Claimed in [BW, 6.16].
testH3ParityOpposite := function()
	local alpha, delta;
	for alpha in H3Pos do
		for delta in H3Sim do
			if H3Parity(alpha, delta) <> H3Parity(-alpha, delta) then
				return false;
			fi;
		od;
	od;
	return true;
end;

# Prints a list of some values of the parity map which are needed in [BW, 8.33].
computeNeededParities := function()
	local alpha, ep, quint;
	alpha := H3Sim[2];
	ep := H3Sim[3];
	quint := H2QuintupleFromPair(alpha, ep);
	Print("eta(alpha, alpha ep): ");
	Print(H3ParityProd(alpha, [ alpha, ep ]), "\n");
	Print("eta(ep, alpha ep): ");
	Print(H3ParityProd(ep, [ alpha, ep ]), "\n");
	Print("eta(beta, alpha ep): ");
	Print(H3ParityProd(quint[2], [ alpha, ep ]), "\n");
	Print("eta(gamma, alpha ep): ");
	Print(H3ParityProd(quint[3], [ alpha, ep ]), "\n");
	Print("eta(delta, alpha ep): ");
	Print(H3ParityProd(quint[4], [ alpha, ep ]), "\n");
end;

testAll := function()
	local testFunc, func;
	# List of all test functions
	testFunc := [ testDecompIsOrtho, testDecompIsInvar, testGH3IsGoldenH3, testH3IsRootSystem, testReflActionLem, testH3SubsysProp, testTwoA2Prop, testComRels, testH3ParityOpposite];
	for func in testFunc do
		if func() = false then
			return false;
		fi;
	od;
	return true;
end;

